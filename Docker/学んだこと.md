[参考](https://qiita.com/daisuke30x/items/a3ea62ff8fa582b2b065)<br>
[参考2](https://y-ohgi.com/introduction-docker/2_component/volume/)

# Dockerfile

## FROM

大抵のDockerfileで最初に読み込む<br>
ベースとなるイメージを決定する

```Dockerfile
FROM tiangolo/uvicorn-gunicorn-fastapi:python3.8
```

## COPY

```Dockerfile
COPY . /app
```

このパターンで言うとすべてのファイルを/appにコピーする(この実例は少し特殊)<br>
似たもので言うとADDがある(ADDでは解凍してコピー、COPYでは解凍はせずそのままコピー)

## RUN

パッケージインストールなどのコマンド(pip install など)

```Dockerfile
RUN pip install sqlalchemy
```

## CMD

コンテナが作成されたあとで実行するコマンドを指定する

```Dockerfile
CMD ["ping","127.0.0.1","-c","100"]
```

# その他基本概念

## volume

Dockerのデータの永続化

Volumeはデータ保持・永続化のために設計されており、コンテナのライフサイクルとは独立してファイルの管理を行う
**わからん**

```yaml
volumes:
  - ./messages:/appp/messages
```
ローカルの./messagesをdocker上の/appp/messagesにマウントする

```yaml
volumes:
  - messages:/appp/messages
```
これだとnamed volumeを使うことになる。

### Volumesには種類がある(**らしい**）
- volume
  - **Docker によって生成され管理される**
  - Docker ホスト上のディレクトリにボリュームが保存される
  - VSCodeのDockerタブから見れるのはこれ(多分)
- bind
  - **ホストマシン上のファイルやディレクトリがコンテナーにマウントされる**
  - コンテナ内に動作するプロセスを通じてホストのファイルシステムに変更がかけられる
- tmpfs
- named pipe

# docker-compose

## 実例

Dockerfile
```dockerfile
FROM python:3.7
WORKDIR /var/www/html
RUN pip install fastapi uvicorn
```

main.py
```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def read_root():
    return {"Hello": "World"}
```

docker-compose.yml
```yaml
version: '3'

services:
  app:
    container_name: FastAPI
    build: ./docker
    volumes:
      - ./src:/var/www/html
    ports:
      - "9004:9004"
    command: uvicorn main:app --reload --host 0.0.0.0 --port 9004
```

